---
layout: post
title: "[LINUX] - 리눅스 기초"
author: Lee Wonseok
categories: LINUX
comments: true
tags: LINUX
cover: "/assets/LINUX.jpg"
---


# LINUX의 기초

**머리말**  
Infra Engineer 로 약 2년정도 실무를 경험했었지만  
군대의 공백 때문에 지식들이 희미해지기 시작했다.  
블로그 글을 정리하며 다시 리와인드.  

---


**목차**

- [리눅스(LINUX) OS의 기본 구성 요소](#a1)
- [리눅스 명령어 정리](#a2)
- [가상메모리](#a3)
- [USER 설정](#a4)
- [권한 설정](#a5)
- [ACL (Access Controll List)](#a6)

----


**PART 1 - 리눅스 (OS) 기초 이론**  


  * **교육 관련 참고 사이트**  

  1. [프로토콜 용어 및 기능 검색](http://ktword.co.kr/word/)
  2. [이론 PPT 드라이브](https://c11.kr/networkbasic)

---------------------------

## **1. 리눅스(LINUX) OS의 기본 구성 요소** <a name="a1"></a> 
   
   * **커널 (Kernel)**  
	**파일 입출력, 프로세스 관리 등과 같이 운영체제의 기능을 담당**  
	- 프로세스 관리 : 프로세스 및 스레드 생성과 삭제, 스케줄링 등  
	- 파일 관리 : 디스크 상의 파일을 관리
	- 메모리 관리 : 메인 메모리를 효과적으로 사용하기 위해 관리  
	- 통신 관리 : 네트워크를 통해 정보를 주고받을 수 있도록 관리  
	- 주변장치 관리 : 입출력 장치를 사용할 수 있도록 관리   

        ![](https://www.fun-coding.org/00_Images/os_arch.png)
        
  <br/>
    
   * **쉘 (Shell)**  
     **OS와 사용자 사이의 인터페이스를 제공하는 소프트웨어로 시스템 콜의 일종**  
    **명령어를 입력받아 이를 처리하는 명령어 처리기**    
        ![](https://mblogthumb-phinf.pstatic.net/MjAxODExMjhfMTEw/MDAxNTQzMzcwMTM0MDYw.G0jp7Gtcwwgt6OxrKpNBLQD-KnxpCl0HjJMbgjg9JX0g.C8rEjP7rStId6U9wcY6LPG1JsqUGAQ2W2gKlsWNJS-sg.PNG.qbxlvnf11/20181128_105346.png?type=w800)
   
<br/>

   * **파일시스템 (File System)**  
     **파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 / 조직하는 체제**  
   파일시스템의 경우 나중에 새로운 포스트로 세부 정리 예정 
     * 저장장치 내에서 데이터를 읽고 쓰기 위해 미리 정해진 약속
     * 파일 저장 및 검색을 용이하도록 유지/관리하는 방법
     * 파일을 어떻게 관리할 것인가에 대한 메커니즘과 정책  
     
  <br/>
     
  * **파일 + 디렉토리 구조**  
    : EXT2, EXT3, FAT, FAT32, NTFS, JFFS, JFFS, JFFS2, ISO 9660 ...  
    : Journaling File System -파일 시스템의 변화를 기록 문제가 발생할 경우 파일 시스템 복구  
    ![](https://t1.daumcdn.net/cfile/tistory/2657C75056A9C44A27)
      
<br/>
		
   * 디렉토리 별 설명
		
	     /boot: 부팅에 필요한 리눅스 커널 및 여타 패키지를 보관
	     /bin: GUI를 실행하는 파일들과 같은 운영체제 관련 바이너리 파일들을 보관	
	     /dev: 저장장치, 사운드카드, 그래픽카드, USB장치 등의 연결된 모든 장치들의 연결점
	     /etc: 사용자 계정과 암호화된 패스워드를 비롯한 여러가지 설정파일들을 보관
	     /home: 각 계정의 홈 디렉토리 관리
	     /lib: 수 많은 어플리케이션들에 의해 공유되는 라이브러리들을 보관
	     /media: USB메모리, 외장형 CD 드라이브등 분리 저장장치가 자동으로 마운팅 되는 지점
	     /mnt: 외부 저장장치를 수동으로 마운팅 하는데 사용되는 디렉토리
	     /opt: 운영체제의 일부가 아닌 소프트웨어를 설치 및 보관하는 디렉토리
	     /proc: 리눅스에서 실행되고 있는 프로그램, 즉 프로세스 정보를 제공하는 디렉토리
	     /sbin: 슈퍼유저에 의해 사용되는 시스템 관리 유틸리티 바이너리 파일들을 보관
	     /sys: 특별한 운영체제 파일들이 있는 디렉토리
	     /tmp: 임시 파일들이 자동으로 보관 되는 곳
	     /usr: 사용자가 접근할 수 있는 프로그램들을 보관하기 위한 디렉토리
	     /var: 프로그램들이 값이 변하는 자료나 변수들을 저장하기 위한 가상 디렉토리


<br/>

---------------------------	

## 2. 리눅스 명령어 정리 <a name="a2"></a>  

<br/>
	
* **간단한 명령어 리스트**

	```
    Show File, Directory 명령어 : ls, cat, more, head, tail, wc
    Copy, Move,Remove 명령어 : cp, mv ,rm ,mkdir
	```

<br/>

* **링크생성 : ln (hard link, symbolic link)**
	
	- **하드 링크 (hard link) - ln [원본파일][링크 파일명]**
	: 원본 파일과 동일한 inode를 가진다.  
  원본 파일이 삭제 되더라도 원본 파일의 inode를 갖고 있는 링크 파일은 여전히 사용 가능

	- **심볼릭 링크 (symbolic link) - ln -s [원본파일][링크 파일명]** 
	: 원본 파일의 이름을 가르키는 링크. 그러므로 원본 파일이 사라지게되면 역할을 수행할 수 없다 

		```
		ex)  조건 : ln [Source] [Target]
		    
		$ ln /home/test /home/home.ln
		-> /home/test 파일의 내용이 /home/home.ln에 하드링크로 구성
		      
 		$ ln -s /home/test /home/home.so
		-> /home/test 파일의 내용이 /home/home.ln에 심볼릭링크로 구성

		% 심볼릭 링크 옵션 : -s
		```

----

## 3. 가상메모리 <a name="a3"></a> 


* 가상메모리 (SWAP)  
	: swap 은 물리 메모리가 부족할 경우를 대비해 만든 영역이다.   
	즉 메모리 부족으로 인한 이슈를 막기위해 확보해놓은 메모리 공간이다.

	* **SWAP 을 쓰는 이유**
	1.  메모리 부족
	2.  멀티태스킹(스와핑, 페이징등 우선순위 프로그램의 리사이클을 위해)
	3.  메모리(full) 덤핑

-   **스와핑** : 전체 프로세스 주소 공간 또는 공유 할 수 없는 텍스트 데이터  
	세그먼트를 스왑 장치에 복사하거나 한 번에 (일반적으로 디스크) 복사하는 것을 말합니다
	
	* swap in : 하드디스크의 프로세스를 메모리에 보내는 행위  
	* swap out : 메모리에서 프로세스는 내보내는 행위  
	
-   **페이징** : 주소 공간의 하나 이상의 페이지를 복사하는 것을 말합니다.   
		특히, 이것은 훨씬 더 미세한 입자입니다
		


* **다음 3가지의 명령어를 가지고 스왑 메모리에 관련된 작업을 수행 할 수 있다.**

	1. 스왑메모리 생성 : **mkswap**  
	2. 스왑메모리 활성화 : **swapon**  
	3. 스왑메모리 비활성화 : **swapoff**
  

      스왑 파티션 생성 방법
      스왑 파티션 생성 전 아래 명령어로 스왑 영역을 확인 할 수 있다.
	  - swapon -s 
	  - free
	  - df 

      1) 파티셔닝을 통한 스왑 영역 활성화
      - 디스크 추가 (fdisk -l /dev/sdc) or parted 명령어
      - 파티셔닝 (fstype : linux swap 82) 
      - 스왑 영역 생성 (mkswap /dev/sdc3) 
      - mount (스왑영역 활성화) (swapon /dev/sdc3 마운트)
      - 활성화 시킨 SWAP을 fstab에 등록
      blkid 또는 lsblk -f 로 /dev/sdc3의 UUID 확인
      vim /etc/fstab
      /dev/sdc6또는 UUID swap swap defaults 0 0
      
      - swapon -a (/etc/fstab의 파일을 현재 메모리에 활성화 해서 오류 확인)
      - swap 을 비활성화 (swapoff /dev/sdc3)   
      
 * **간단한 swap 메모리 증설 방법**

         1. sudo dd if=/dev/zero of=/root/fileA count=4000 bs=1024k  //dd : 블록단위로 파일을 복사,저장 하는 명령어
         2. sudo chmod 600 /root/fileA                               // 권한 설정
         3. sudo mkswap /root/fileA                                  // 해당 파일로 스왑 생성
         4. sudo swapon /root/fileA
         5. fatab 등록
 
 
 ----

## 4. USER 설정 <a name="a4"></a> 

* **사용자 및 그룹 정보 파일** 

		 * /etc/passwd : 시스템에 등록된 사용자 정보
		 * /etc/shadow : 시스템에 등록된 사용자의 PWD 및 PWD 설정
		 * /etc/group : 시스템에 등록된 그룹 정보
		 * /etc/gshadow  : 시스템에 등록된 그룹의 PWD 및 PWD 설정


* **사용자(그룹) 생성 및 수정,삭제 명령어**
		
		*	useradd (유저 생성) [grouppadd]
		*	usermod (유저 정보 수정) [groupmod]
		*	userdel (유저 삭제, -r 옵션으로 홈디렉토리까지 삭제가 기본) [groupdel]

		
* **명령어 형식 [add와 mod 거의 동일]**


          # useradd 옵션 계정명  
  
	      **옵션  
	      -d 홈디렉토리 : 홈디렉토리의 경로를 지정해줍니다. 홈디렉토리를 생성할려면 -m 옵션을 같이 사용합니다.  
	      -u uid : uid 를 지정합니다.  
	      -g gid : gid 그룹을 지정합니다.  
	      -G groups : 보조그룹을 지정합니다.  
	      -s shell : 쉘을 지정합니다.  
	      -c 주석 : 계정에 설명을 붙여 줍니다.  
	      -D : useradd 의 기본 설정 값을 확인합니다. 기본 설정은 /etc/default/useradd 에 있습니다.  

----

## 5. 권한 설정 <a name="a5"></a> 

* **파일, 디렉토리 권한 설정**  
	 ls -l 명령을 사용하여 파일, 디렉토리 리스트를 출력하면 **권한(퍼미션, 허가권)을 확인**할 수 있습니다.

  
	  -rwxr-xr-x 1 pi pi 5720 Jul 3 20:06 a.out
	  -rw-r--r-- 1 pi pi 722 Jul 2 21:12 crontab.bak
	  -rw-r--r-- 1 pi pi 52 Jul 2 21:10 test.c

	  출력 결과는 각각 파일종류 및 권한(퍼미션), 링크수, 사용자(소유자), 그룹, 파일크기, 수정시간, 파일이름을 나타냅니다.

	*	**권한 설정 명령어**
		*	chmod
		*	chown
		*	chgrp


	**개별적으로 파일 권한 변경하기**  
	알파벳, 숫자로 권한을 설정 할 수 있다.


	  chmod g+w test.c
	  그룹에 쓰기 권한을 준다.

	  chmod o-r test.c
	  다른 사용자에게 읽기 권한을 빼앗는다.
	 
	  chmod 777 test.c
	  사용자, 그룹, 다른사용자의 모든 권한을 추가한다.

	  chmod 700 test.c
	  사용자에게만 모든 권한을 준다.

	  chmod 744 test.c
	  사용자에게는 모든 권한을 주고, 그룹, 다른 사용자에게는 읽기 권한만 준다.

	**파일의 소유자 변경**

	  sudo chown user01 a.out
	  chown 명령으로 파일을 사용자(소유자)를 user01로 변경한다.

	  sudo chgrp user01 test.c
	  chgrp 명령으로 파일의 그룹을 user01로 변경한다.

	  그룹만 변경할 때 chgrp 명령어를 사용한다.
	  일반 사용자는 자신이 속한 그룹으로만 변경이 가능하다.

	  sudo chown user02.user02 crontab.bak
	  chown 명령으로 파일의 사용자와 그룹을 동시에 변경한다.

	  sudo chown -R user01 tmp/
	  -R 옵션을 사용하면 디렉토리와 그 안에 들어있는 모든 파일의 사용자를 변경한다.

---

<br/>

*  **특수권한**

* **1. SetUID**  
	
	- 소유자만 접근 가능한 파일에 일반 유저로 접근이 필요할 때 사용한다. 권한을 잠시 빌려오는 개념.
  	- User 권한의 접근 권한(x)자리에 x대신 s가 들어가면 이를 SetUID라 칭한다.
  	- 만약 s 대신 S(대문자)가 들어가면 이는 일반 권한의 -(접근 권한 없음) 과 같은 의미이다.
  	- 권한을 읽을 때 맨 앞에 숫자 4를 붙여서 읽는다



	*	명령어 형식
		  * chmod u+s 파일이름
		  * chmod 4755 파일이름  


	```
    ex) rws rwx rwx = 4777
	chmod u+s test.sh
	chmod 4775 text,sh
	```   
	      
<br/>
  
	
	
* **2. SetGID**

	- 소유 그룹만 접근 가능한 파일에 일반유저로 접근이 필요할 때 사용한다.
	- Group 권한의 접근 권한(x)자리에 x대신 s가 들어가면 이를 SetGID라 칭한다.
	- 만약 s 대신 S(대문자)가 들어가면 이는 일반 권한의  -(접근 권한 없음) 과 같은 의미이다.
	- 권한을 읽을 때 맨 앞에 숫자 2를 붙여서 읽는다.

	
	*	명령어 형식  
      	* chmod g+s 파일이름  
      	* chmod 2755 파일이름  
      
	```
    ex) rwx rws rwx = 2777
	chmod g+s test.sh
	chmod 2775 text,sh  
	```
			
* **3. Sticky bit**

	- 특정 디렉토리를 누구나 자유롭게 사용할 수 있도록한다.
	- 파일 및 디렉토리 생성은 누구나 가능지만, 삭제는 생성한 유저와 디렉토리 소유자만 가능하다.

	**(게시판의 개념으로 생각)**

	- Other 권한의 접근 권한(x)자리에 x대신 t가 들어가면 이를 Sticky bit라 칭한다.
	- 만약 t 대신 T(대문자)가 들어가면 이는 일반 권한의 -(접근 권한 없음) 과 같은 의미이다.
	- 권한을 읽을 때 맨 앞에 숫자 1을 붙여서 읽는다.
	
  		*	명령어 형식  
    	* chmod o+t 파일이름
    	* chmod 1755 파일이름

	```
	ex) rwx rwx rwt = 1777
	chmod o+t test.sh
	chmod 1775 text,sh
	```

<br/>

---

<br/>

## 6.ACL (Access Controll List) <a name="a6"></a>   

<br/>

* **setfacl 과 getfacl**  
	
	```
	어떤 파일에 대해 alice, bob 사용자에게 읽기 권한만 주고  
	Eve와 Frank는 읽기/쓰기 권한을 주는 등의 세밀한 권한 조정은 불가능했다.

	이같은 문제를 해결하기 위해 (ACL; Access Control List)을 구현했고  
	cp, mv 같은 파일을 다루는 유틸리티도 ACL 에 맞게 수정됐다.  

	ACL 설정 (Link to ACL 설정)  
	
	ACL 은 access ACL 과 기본 ACL 두 가지 형식이 있다.  
	access ACL 은 지정한 파일이나 디렉터리에 대해 설정한 접근 제어 목록이며  
	기본 ACL 은 디렉터리에만 지정할 수 있고 필수 사항은 아니다.

	디렉토리에 들어있는 파일에 access ACL 이 설정돼 있지 않으면  
	디렉토리에 지정된 기본 ACL 을 사용하게 된다.  
	ACL 은 사용자별, 그룹별, 유효 접근 권리 마스크(effective rights mask) 별  
	그리고 다른 사용자(other)에 대해 설정할 수 있다.  
	```


---

<br/>

* **ACL 추가/변경Link to ACL 추가/변경**  
	**``-m 옵션``을 사용하면 파일이나 디렉터리의 ACL 을 추가 또는 변경할 수 있다.**  
	
	setfacl -m rules files 와 같은 형식으로 사용하면 된다.  
	rule 은 필수 항목이며 다음과 같이 설정할 수 있다.

	```
    u:uid:perms
    특정 사용자를 대상으로 ACL 을 설정한다. 대상 사용자는 사용자 ID나 UID(숫자)로 지정하면 되며 유효한 사용자여야 한다.
      
	g:gid:perms
    그룹을 대상으로 권한을 지정하며, 대상 그룹은 그룹 명이나 GID(숫자) 로 지정하며 유효한 그룹이여야 한다.
      
	o:perms
    다른 사용자(other)에 대해 ACL 을 지정한다. perms 에 지정하는 권한은 r(읽기), w(쓰기), x(실행) 세 가지로 나눠지며 여러 권한을 지정할 경우 권한 문자를 이어서 써주면 된다. 예를 들어 읽기, 쓰기를 허용할 경우 rw 를 지정하면 된다.
	```

<br/>

* **ACL 삭제Link to ACL 삭제**  

	**``-x, --remove 옵션``을 사용하면 ACL 을 삭제할 수 있다.**  
	
	-m 과 마찬가지로 rules 과 파일명을 주게 되어 있으나  
	권한 항목은 지정할 수 없으며, 지정된 사용자와 그룹의 모든 권한을 삭제한다.  




	**실행 예**

	```
	일반 사용자는 /etc/sysconfig/iptables 파일의 내용을 볼 수가 없다.
	따라서 won 사용자에게만 /etc/sysconfig/iptables 파일을 볼 수 있는 권한을 부여해 보자.

	# setfacl -m u:won:r /etc/sysconfig/iptables


	won 사용자에게 부여한 /etc/sysconfig/iptables 의 모든 권한을 삭제해 보자. 

	# setfacl -x u:won /etc/sysconfig/iptables

	이제 lesstif 사용자가  /etc/sysconfig/iptables 을 읽으려고 할 경우 
	"Permission denied" 에러가 발생하게 된다.
	```



	**실행 예 (2)**
	```
	/project/config 파일은 devel 그룹은 읽고 쓸 수 있고
	lesstif 사용자는 읽을 수만 있도록 설정해 보자.

	# setfacl -m g:devel:rw /project/config
	# setfacl -m u:lesstif:r /project/config
	```

<br/>

---

<br/>

* **기본 ACL 설정 Link to 기본 ACL 설정**  
	rules 항목 앞에 ``d``를 붙이면 된다.  
	디렉토리에만 가능하므로 파일에 지정할 경우 에러가 발생한다.  

<br/>

* **ACL 확인 Link to ACL 확인**

	```
	getfacl 명령어로 파일이나 디렉터리에 설정된 ACL 을 확인할 수 있다.
	일례로 시스템 로그가 쌓이는 /var/log 의 ACL 을 확인해 보자. 

	getfacl /var/log
 
	getfacl: Removing leading '/' from absolute path names
	# file: var/log
	# owner: root
	# group: root
	user::rwx
	group::r-x
	other::r-x
	```

	/var/log 의 소유자는 root 이고 그룹도 root 이다.  
	소유자는 읽기(r), 쓰기(w), 실행(x) 권한을 갖고 있고  
	그룹과 다른 사용자에게는 읽기(r), 실행(x) 권한이 있음을 확인할 수 있다

<br/>

----
